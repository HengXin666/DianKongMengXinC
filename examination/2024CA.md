# C语言A卷
## 1、余数表
$p \times q$ 的余数表, 要求用户可以输入两个正整数( $p, q$ ; 其中 $p ≥ q$ )

- 特别要求: 因为学长方舟抽了40抽歪了, 所以我们需要剔除 **任何** $4$ 的倍数的数字作为被除数和除数 以及 **包含** $4$ 这个数字的数 时候的式子

> 注: $p$ 是列方向(打竖的), $q$ 是行方向(打横的)!
>
> 例如: 4, 14, 114514, 47 这种含有4这个数字的数的式子都要剔除
>
> 注意逗号的打印, 如果一行全部被剔除了, 请显示为`\n`

- 下面是运行示例:

```C
请输入p和q: 5 4

这个是 5 * 4 的余数表
5 ÷ 1 = 5 ... 0, 5 ÷ 2 = 2 ... 1, 5 ÷ 3 = 1 ... 2

3 ÷ 1 = 3 ... 0, 3 ÷ 2 = 1 ... 1, 3 ÷ 3 = 1 ... 0
2 ÷ 1 = 2 ... 0, 2 ÷ 2 = 1 ... 0
1 ÷ 1 = 1 ... 0
```

```C
请输入p和q: 3 3

这个是 3 * 3 的余数表
3 ÷ 1 = 3 ... 0, 3 ÷ 2 = 1 ... 1, 3 ÷ 3 = 1 ... 0
2 ÷ 1 = 2 ... 0, 2 ÷ 2 = 1 ... 0
1 ÷ 1 = 1 ... 0
```

### 答案
- 参考答案 1:

```C++
#include <stdio.h>

int containsFour(int num) {
    while (num > 0) {
        if (num % 10 == 4) {
            return 1; // 如果包含数字4，返回1
        }
        num /= 10;
    }
    return 0; // 不包含数字4，返回0
}

int isMultipleOfFour(int num) {
    return num % 4 == 0; // 检查是否是4的倍数
}

void printRemainderTable(int p, int q) {
    printf("这个是 %d * %d 的余数表\n", p, q);

    for (int i = p; i >= 1; --i) {
        if (containsFour(i) || isMultipleOfFour(i)) {
            printf("\n");
            continue; // 跳过含4或是4的倍数的被除数
        }

        int firstColumn = 0; // 检查这一行是否打印了内容

        for (int j = 1; j <= q && j <= i; ++j) {
            if (containsFour(j) || isMultipleOfFour(j)) {
                continue; // 跳过含4或是4的倍数的除数
            }

            int quotient = i / j; // 商
            int remainder = i % j; // 余数

            // 打印结果
            if (firstColumn) {
                printf(", "); // 如果不是第一列，前面加逗号
            }
            printf("%d ÷ %d = %d ... %d", i, j, quotient, remainder);
            firstColumn = 1; // 标记这一行已经打印了内容
        }
                  
        printf("\n");
    }
}

int main() {
    int p, q;
    printf("请输入p和q: ");
    scanf("%d %d", &p, &q);

    if (p < q) {
        printf("错误: p 应该大于等于 q。\n");
        return 1; // 输入无效，退出
    }

    printRemainderTable(p, q);

    return 0; // 程序结束
}
```


### 评分 (15分)

- 以正确的格式打印 (8分)
    - 其中, (倒)阶梯型 (3分)
    - `,`号控制 (3分)
    - 排查一行, 显示为`\n` (2分)

- 正确判断是否为 4 的倍数 (2分)

- 正确判断是否包含 4 这个数字 (5分)

> 看bug大小, 予以适当扣分!

输出示例:
```C
请输入p和q: 16 15
这个是 16 * 15 的余数表

15 ÷ 1 = 15 ... 0, 15 ÷ 2 = 7 ... 1, 15 ÷ 3 = 5 ... 0, 15 ÷ 5 = 3 ... 0, 15 ÷ 6 = 2 ... 3, 15 ÷ 7 = 2 ... 1, 15 ÷ 9 = 1 ... 6, 15 ÷ 10 = 1 ... 5, 15 ÷ 11 = 1 ... 4, 15 ÷ 13 = 1 ... 2, 15 ÷ 15 = 1 ... 0

13 ÷ 1 = 13 ... 0, 13 ÷ 2 = 6 ... 1, 13 ÷ 3 = 4 ... 1, 13 ÷ 5 = 2 ... 3, 13 ÷ 6 = 2 ... 1, 13 ÷ 7 = 1 ... 6, 13 ÷ 9 = 1 ... 4, 13 ÷ 10 = 1 ... 3, 13 ÷ 11 = 1 ... 2, 13 ÷ 13 = 1 ... 0

11 ÷ 1 = 11 ... 0, 11 ÷ 2 = 5 ... 1, 11 ÷ 3 = 3 ... 2, 11 ÷ 5 = 2 ... 1, 11 ÷ 6 = 1 ... 5, 11 ÷ 7 = 1 ... 4, 11 ÷ 9 = 1 ... 2, 11 ÷ 10 = 1 ... 1, 11 ÷ 11 = 1 ... 0
10 ÷ 1 = 10 ... 0, 10 ÷ 2 = 5 ... 0, 10 ÷ 3 = 3 ... 1, 10 ÷ 5 = 2 ... 0, 10 ÷ 6 = 1 ... 4, 10 ÷ 7 = 1 ... 3, 10 ÷ 9 = 1 ... 1, 10 ÷ 10 = 1 ... 0
9 ÷ 1 = 9 ... 0, 9 ÷ 2 = 4 ... 1, 9 ÷ 3 = 3 ... 0, 9 ÷ 5 = 1 ... 4, 9 ÷ 6 = 1 ... 3, 9 ÷ 7 = 1 ... 2, 9 ÷ 9 = 1 ... 0

7 ÷ 1 = 7 ... 0, 7 ÷ 2 = 3 ... 1, 7 ÷ 3 = 2 ... 1, 7 ÷ 5 = 1 ... 2, 7 ÷ 6 = 1 ... 1, 7 ÷ 7 = 1 ... 0
6 ÷ 1 = 6 ... 0, 6 ÷ 2 = 3 ... 0, 6 ÷ 3 = 2 ... 0, 6 ÷ 5 = 1 ... 1, 6 ÷ 6 = 1 ... 0
5 ÷ 1 = 5 ... 0, 5 ÷ 2 = 2 ... 1, 5 ÷ 3 = 1 ... 2, 5 ÷ 5 = 1 ... 0

3 ÷ 1 = 3 ... 0, 3 ÷ 2 = 1 ... 1, 3 ÷ 3 = 1 ... 0
2 ÷ 1 = 2 ... 0, 2 ÷ 2 = 1 ... 0
1 ÷ 1 = 1 ... 0
```


<div style="margin-top: 80px;">

---
</div>

## 2、指指点点

要求用户输入5个整数, 并使用指针将这些整数存储在一个数组中, 然后程序使用 **指针** 遍历数组并将用户输入的整数逐个按 **从小到大** 打印出来。

下面是运行示例:

```C
输入:
第一项: 5
第二项: 4
第三项: 3
第四项: 2
第五项: 1

输出:
第一项: 1
第二项: 2
第三项: 3
第四项: 4
第五项: 5
```

> 注意, 输入数据也可能是`{0, 0, 7, 2, 1}`, 不一定是具有单调性!
>
> 输入/输出 只需要录入/输出数字即可, 不需要上面的中文提示! (但是需要换行!)

### 答案

- 参考答案0: (也就5个数, 暴力全排列一个一个匹配...或者说是`扫描线`找最大、次大、次次大...)其他思路, 输出正确就行. 此处不讨论算法.

- 参考答案1: (冒泡排序)

```C
#include <stdio.h>

int main() {
    int arr[5];
    
    // 输入5个整数
    for (int i = 0; i < 5; i++) {
        scanf("%d", (arr + i));
    }

    // 冒泡排序
    for (int i = 0; i < 5 - 1; i++) {
        for (int j = 0; j < 5 - i - 1; j++) {
            if (*(arr + j) > *(arr + j + 1)) {
                // 交换元素
                int temp = *(arr + j);
                *(arr + j) = *(arr + j + 1);
                *(arr + j + 1) = temp;
            }
        }
    }

    // 输出排序后的结果
    for (int i = 0; i < 5; i++) {
        printf("%d\n", *(arr + i));
    }

    return 0;
}
```

- 参考答案2: (快速排序) (参考)

```C
#include <stdio.h>

void quicksort(int arr[], int left, int right) {
    if (left >= right) return;

    int pivot = *(arr + left);
    int i = left;
    int j = right;

    while (i < j) {
        while (i < j && *(arr + j) >= pivot)
            j--;
        if (i < j)
            *(arr + i++) = *(arr + j);
        while (i < j && *(arr + i) <= pivot)
            i++;
        if (i < j)
            *(arr + j--) = *(arr + i);
    }

    *(arr + i) = pivot;
    quicksort(arr, left, i - 1);
    quicksort(arr, i + 1, right);
}

int main() {
    int arr[5];
    
    // 输入5个整数
    for (int i = 0; i < 5; i++) {
        scanf("%d", (arr + i));
    }

    // 快速排序
    quicksort(arr, 0, 4);

    // 输出排序后的结果
    for (int i = 0; i < 5; i++) {
        printf("%d\n", *(arr + i));
    }

    return 0;
}
```

### 评分 (15分)

- 使用指针进行遍历 (仅要求输出时候的`for`中使用`*(arr + i)`这种) (5分)

- 10 个 评测点, 一个 1 分:

```C
// 定义一个二维数组，存放10组测试数据，每组包含5个整数
int test_cases[10][5] = {
    {1, 2, 3, 4, 5},  // 评测点1: 升序输入
    {5, 4, 3, 2, 1},  // 评测点2: 降序输入
    {3, 3, 3, 3, 3},  // 评测点3: 全部相同数字
    {2, 1, 2, 1, 2},  // 评测点4: 交替数字
    {0, 0, 7, 2, 1},  // 评测点5: 包含0和非0的混合数字
    {-1, -3, -2, -5, -4},  // 评测点6: 全负数
    {114514, 1 << 30, 50, 0, 10086},  // 评测点7: 大数字混合
    {1, 2, 2, 1, 1},   // 评测点8: 包含重复数字
    {0, -1, 1, 2, -2}, // 评测点9: 负数和正数混合
    {755, 0, -633, 822, -911} // 评测点10: 不规则的数字序列
};
```

<div style="margin-top: 80px;">

---
</div>

## 3、[最厉害的学生](https://www.luogu.com.cn/problem/P5740)

### 题目描述

现有 $N$ 名同学参加了期末考试, 并且获得了每名同学的信息:

- 姓名（不超过 $8$ 个字符的仅有英文小写字母的字符串）、
- 语文、
- 数学、
- 英语成绩（所有成绩均为不超过 $150$ 的自然数）。

总分最高的学生就是最厉害的, 请输出最厉害的学生各项信息（姓名、各科成绩）。如果有多个总分相同的学生, 输出靠前的那位。

> 请使用结构体相关知识进行作答! (若没有结构体, 则 0 分)

### 输入格式

第一行输入一个正整数 $N$, 表示学生个数。

第二行开始, 往下 $N$ 行, 对于每一行首先先输入一个字符串表示学生姓名, 再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。

### 输出格式

输出最厉害的学生。

### 样例 #1

#### 样例输入 #1

```
3
senpai 114 51 4
lxl 114 10 23
fafa 51 42 60
```

#### 样例输出 #1

```
senpai 114 51 4
```

### 提示

数据保证, $1 \leq N \leq 1000$, 姓名为长度不超过 $8$ 的字符串, 语文、数学、英语成绩均为不超过 $150$ 的自然数。

### 答案

- 参考答案1:

```C
#include <stdio.h>
#include <string.h>

#define MAX_NAME_LEN 9  // 姓名长度限制（8个字符 + '\0'）

// 定义学生结构体
struct Student {
    char name[MAX_NAME_LEN];
    int chinese;
    int math;
    int english;
    int total;  // 总分
};

int main() {
    int N;
    
    // 输入学生个数
    scanf("%d", &N);
    
    struct Student students[N];  // 存储所有学生信息
    int maxIndex = 0;  // 用来记录最高分学生的索引

    // 读取每个学生的信息
    for (int i = 0; i < N; ++i) {
        // 输入学生姓名和成绩
        scanf("%s %d %d %d", students[i].name, &students[i].chinese, &students[i].math, &students[i].english);
        // 计算总分
        students[i].total = students[i].chinese + students[i].math + students[i].english;

        // 比较当前学生与当前总分最高的学生，找到总分最高的学生
        if (students[i].total > students[maxIndex].total) {
            maxIndex = i;
        }
    }

    // 输出总分最高的学生信息
    printf("%s %d %d %d\n", students[maxIndex].name, students[maxIndex].chinese, students[maxIndex].math, students[maxIndex].english);

    return 0;
}
```

- 参考答案2:

> 实际上只需要用两个结构体实例，一个用于存储当前输入的学生信息，另一个用于存储目前为止总分最高的学生信息。通过每次输入后直接比较来更新总分最高的学生。这样不仅减少了内存的使用，也让代码更加简洁。

```C++
#include <stdio.h>
#include <string.h>

#define MAX_NAME_LEN 9  // 姓名长度限制（8个字符 + '\0'）

// 定义学生结构体
struct Student {
    char name[MAX_NAME_LEN];
    int chinese;
    int math;
    int english;
    int total;  // 总分
};

int main() {
    int N;
    
    // 输入学生个数
    scanf("%d", &N);

    struct Student currentStudent, bestStudent;  // 当前学生和总分最高的学生
    bestStudent.total = -1;  // 初始化为一个很小的值，确保第一个学生的总分能更新

    // 读取每个学生的信息
    for (int i = 0; i < N; ++i) {
        // 输入当前学生的姓名和成绩
        scanf("%s %d %d %d", currentStudent.name, &currentStudent.chinese, &currentStudent.math, &currentStudent.english);
        
        // 计算当前学生的总分
        currentStudent.total = currentStudent.chinese + currentStudent.math + currentStudent.english;

        // 如果当前学生的总分高于目前最高分的学生，或者在总分相同时学生排名靠前，则更新最厉害的学生
        if (currentStudent.total > bestStudent.total) {
            bestStudent = currentStudent;  // 直接复制整个结构体
        }
    }

    // 输出最厉害的学生信息
    printf("%s %d %d %d\n", bestStudent.name, bestStudent.chinese, bestStudent.math, bestStudent.english);

    return 0;
}
```

### 评分 (20分)

- 正确的定义结构体 (5分)
- 正确的接收输入数据 (5分)
- 洛谷评测, 1个测试点 1 分 (10分)

<div style="margin-top: 80px;">

---
</div>

## 4、[[NOIP2015 提高组] 神奇的幻方](https://www.luogu.com.cn/problem/P2615)

幻方是一种很神奇的 $N\times N$ 矩阵: 它由数字 $1,2,3,\cdots \cdots ,N \times N$ 构成, 且每行、每列及两条对角线上的数字之和都相同。

当 $N$ 为奇数时, 我们可以通过下方法构建一个幻方:

首先将 $1$ 写在第一行的中间。

之后, 按如下方式从小到大依次填写每个数 $K \ (K=2,3,\cdots,N \times N)$:

1. 若 $(K-1)$ 在第一行但不在最后一列, 则将 $K$ 填在最后一行,  $(K-1)$ 所在列的右一列；

2. 若 $(K-1)$ 在最后一列但不在第一行, 则将 $K$ 填在第一列,  $(K-1)$ 所在行的上一行；

3. 若 $(K-1)$ 在第一行最后一列, 则将 $K$ 填在 $(K-1)$ 的正下方；

4. 若 $(K-1)$ 既不在第一行, 也不在最后一列, 如果 $(K-1)$ 的右上方还未填数, 则将 $K$ 填在 $(K-1)$ 的右上方, 否则将 $K$ 填在 $(K-1)$ 的正下方。

现给定 $N$, 请按上述方法构造 $N \times N$ 的幻方。

### 输入格式

一个正整数 $N$, 即幻方的大小。

### 输出格式

共 $N$ 行, 每行 $N$ 个整数, 即按上述方法构造出的 $N \times N$ 的幻方, 相邻两个整数之间用单空格隔开。

### 样例 #1

#### 样例输入 #1

```
3
```

#### 样例输出 #1

```
8 1 6
3 5 7
4 9 2
```

### 样例 #2

#### 样例输入 #2

```C
25
```

#### 样例输出 #2

```C
327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325
353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326
379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352
405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378
431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404
457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430
483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456
509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482
535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508
561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534
587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560
613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586
14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612
40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13
66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39
92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65
118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91
144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117
170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143
196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169
222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195
248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221
274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247
300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273
301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299
```

### 提示

对于 $100\%$ 的数据, 对于全部数据, $1 \leq N \leq 39$ 且 $N$ 为奇数。

### 答案

- 参考答案 1

```C++
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    scanf("%d", &n);
    int **arr = (int**)malloc(n * sizeof(int*));

    for (int i = 0; i < n; ++i) {
        int* a = (int*)malloc(n * sizeof(int));
        for (int j = 0; j < n; ++j) {
            a[j] = 0;
        }
        arr[i] = a;
    }

    arr[0][n >> 1] = 1; // 初始化中间位置
    int sum = n * n;

    for (int k = 2, i = 0, j = n >> 1; k <= sum; ++k) {
        if (i == 0 && j != n - 1) {        // 1. k-1 在第一行但不在最后一列
            i = n - 1;
            ++j;
        } else if (i != 0 && j == n - 1) { // 2. k-1 不在第一行但在最后一列
            j = 0;
            --i;
        } else if (i == 0 && j == n - 1) { // 3. k-1 在第一行最后一列
            ++i;
        } else {
            if (!arr[i - 1][j + 1]) {      // 未填
                --i;
                ++j;
            } else {
                ++i;
            }
        }
        arr[i][j] = k;
    }

    // 输出结果
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }

    // 释放内存
    for (int i = 0; i < n; ++i) {
        free(arr[i]);
    }
    free(arr);

    return 0;
}

```

更多答案可以去看: https://www.luogu.com.cn/problem/solution/P2615

### 评分 (20分)

- 正确的读入 (2分)
- 正确的存放 (分配数组空间, `int arr[n][n]`或者`malloc`或者`int arr[40][40]`) (3分)

- 洛谷评测, 前 6 个评测点 1 分/个 (测试点`#2`2分), 后 4 个评测点 2 分/个 

<div style="margin-top: 80px;">

---
</div>

## 5、[连接二进制表示可形成的最大数值 ](https://leetcode.cn/problems/maximum-possible-number-by-binary-concatenation/)

~~(力扣 第 418 场周赛 Q1 Heng_Xin改)~~

给你一个包含三个`int`成员的`Node`结构体`nums`。

现以某种顺序**连接**结构体`nums`中所有成员的**二进制表示**, 请你返回可以由这种方法形成的 **最大** 数值。

**注意:** 任何数字的二进制表示 **不含** 前导零。

### 示例
```C
注: nums = [a, b, c] 即 {
    struct Node nums;
    nums.a = a;
    nums.b = b;
    nums.c = c;
} 的简写!

示例 1:
输入: nums = [1,2,3]
输出: 30
解释:
  按照顺序 [3, 1, 2] 连接数字的二进制表示, 
  得到结果 "11 1 10", 这是 30 的二进制表示。

示例 2:
输入: nums = [2,8,16]
输出: 1296
解释:
  按照顺序 [2, 8, 16] 连接数字的二进制表述, 
  得到结果 "10 1000 10000", 这是 1296 的二进制表示。
```

### 提示

- `1 <= nums.a, nums.b, nums.c <= 127`

### 模版

> 请使用模版, 并且只能添加内容, 而 **不能** 删除原有的内容 (除了注释) (否则 0 分)
>
> 具体要求, 已经在注释中说明!

```C
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int a;
    int b;
    int c;
};

struct Node* newNode(int a, int b, int c);
void freeNode(struct Node** nums);
int maxGoodNumber(struct Node* nums);

struct Node* newNode(int a, int b, int c) {
    struct Node* res = (struct Node* )malloc(sizeof(struct Node));
    res->a = a;
    res->b = b;
    res->c = c;
    return res;
}

void freeNode(struct Node** nums) {
    free(*nums);
    *nums = NULL;
}

int maxGoodNumber(struct Node* nums) {
    // 请在此处编写, 主逻辑, 之后我们将会通过调用 maxGoodNumber 来确定逻辑是否正确
    // 您可以自由的添加函数等等, 但是不能修改原有的代码!
}

int main() {
    int a = 1, b = 2, c = 3;
    printf("a = %d, b = %d, c = %d\n", a, b, c);
    // 您需要在此处提供一个运行示例, 即调用 newNode, maxGoodNumber, 以及 freeNode
    // 需要输出 maxGoodNumber 的返回值, 即 30
    return 0;
}
```

### 答案

- 参考答案 1

```C
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int a;
    int b;
    int c;
};

struct Node* newNode(int a, int b, int c);
void freeNode(struct Node** nums);
int maxGoodNumber(struct Node* nums);

struct Node* newNode(int a, int b, int c) {
    struct Node* res = (struct Node* )malloc(sizeof(struct Node));
    res->a = a;
    res->b = b;
    res->c = c;
    return res;
}

void freeNode(struct Node** nums) {
    free(*nums);
    *nums = NULL;
}

int max(int a, int b) {
    return a > b ? a : b;
}

int bitLen(int x) {
    int len = 0;
    while (x) {
        ++len;
        x >>= 1;
    }
    return len;
}

int montage(int a, int b, int c) {
    int res = c;
    res |= b << bitLen(res);
    res |= a << bitLen(res);
    return res;
}

int maxGoodNumber(struct Node* nums) {
    // 直接手撸 [a, b, c] 的全排列:
    int res = montage(nums->a, nums->b, nums->c);
    res = max(res, montage(nums->a, nums->c, nums->b));
    res = max(res, montage(nums->b, nums->a, nums->c));
    res = max(res, montage(nums->b, nums->c, nums->a));
    res = max(res, montage(nums->c, nums->a, nums->b));
    return res = max(res, montage(nums->a, nums->b, nums->a));
}

int main() {
    int a = 1, b = 2, c = 3;
    printf("a = %d, b = %d, c = %d\n", a, b, c);
    struct Node* nums = newNode(a, b, c);
    printf("maxGoodNumber: %d\n", maxGoodNumber(nums)); // 提供一个示例
    freeNode(&nums);
    return 0;
}
```

参考答案2 (思路)

```C
int maxGoodNumber(int* nums, int numsSize) {
    int l[3], x, ans = 0;
    for (int i = 0; i < 3; ++ i) 
        for (x = nums[i]; x; x >>= 1) 
            ++ l[i];
    if ((x = nums[0] << (l[1] + l[2]) | nums[1] << l[2] | nums[2]) > ans)
        ans = x;
    if ((x = nums[0] << (l[1] + l[2]) | nums[2] << l[1] | nums[1]) > ans)
        ans = x;
    if ((x = nums[1] << (l[2] + l[0]) | nums[2] << l[0] | nums[0]) > ans)
        ans = x;
    if ((x = nums[1] << (l[2] + l[0]) | nums[0] << l[2] | nums[2]) > ans)
        ans = x;
    if ((x = nums[2] << (l[0] + l[1]) | nums[0] << l[1] | nums[1]) > ans)
        ans = x;
    if ((x = nums[2] << (l[0] + l[1]) | nums[1] << l[0] | nums[0]) > ans)
        ans = x;
    return ans;
}
```

参考答案3 (无懈可击, 非暴力) [贪心]

> 如果你想看看的话, 可以看看...

```C++
class Solution { // By 0x3f
public:
    int maxGoodNumber(vector<int>& nums) {
        ranges::sort(nums, [](int a, int b) {
            int len_a = __lg(a) + 1;
            int len_b = __lg(b) + 1;
            return (a << len_b | b) > (b << len_a | a);
        });

        int ans = 0;
        for (int x : nums) {
            ans = ans << (__lg(x) + 1) | x;
        }
        return ans;
    }
};
```

> 类似思路的证明, 请看 https://leetcode.cn/problems/largest-number/solutions/715680/zui-da-shu-by-leetcode-solution-sid5/

### 验证

```C
// 添加这个函数
int test(int a, int b, int c) {
    printf("a = %d, b = %d, c = %d | ", a, b, c);
    struct Node* nums = newNode(a, b, c);
    printf("maxGoodNumber: %d\n", maxGoodNumber(nums));
    freeNode(&nums);
}

// main函数添加 如: test(1, 2, 3);
// 即可快速测试代码算法的正确性
```

### 评分 (30分)

- 是否正确的调用`newNode`  (5分)
- 是否正确的调用`freeNode` (5分)

- `maxGoodNumber`的正确性, 通过下面的`runTests`函数, 按照测试点给分 (20分)

```C
int test(int a, int b, int c) {
    struct Node* nums = newNode(a, b, c);
    int res = maxGoodNumber(nums);
    freeNode(&nums);
    return res;
}

int max(int a, int b) {
    return a > b ? a : b;
}

int bitLen(int x) {
    int len = 0;
    while (x) {
        ++len;
        x >>= 1;
    }
    return len;
}

int montage(int a, int b, int c) {
    int res = c;
    res |= b << bitLen(res);
    res |= a << bitLen(res);
    return res;
}

int _hxMaxGoodNumber(struct Node* nums) {
    int res = montage(nums->a, nums->b, nums->c);
    res = max(res, montage(nums->a, nums->c, nums->b));
    res = max(res, montage(nums->b, nums->a, nums->c));
    res = max(res, montage(nums->b, nums->c, nums->a));
    res = max(res, montage(nums->c, nums->a, nums->b));
    return res = max(res, montage(nums->a, nums->b, nums->a));
}

int goodTest(int a, int b, int c) {
    struct Node* nums = newNode(a, b, c);
    int res = _hxMaxGoodNumber(nums);
    freeNode(&nums);
    return res;
}

void runTests() {
    int testCases[20][3] = {
        {1, 1, 1},        // 边界值，所有数最小
        {127, 127, 127},  // 边界值，所有数最大
        {1, 127, 1},      // 最小和最大值组合
        {127, 1, 127},    // 最大和最小值组合
        {64, 64, 64},     // 中间值，所有数相等
        {127, 1, 64},     // 最大、最小、中间值组合
        {1, 64, 127},     // 最小、中间、最大值组合
        {64, 1, 127},     // 中间、最小、最大值组合
        {127, 127, 1},    // 最大值重复，包含最小值
        {1, 127, 127},    // 最小值和最大值重复
        {64, 64, 127},    // 中间值重复，包含最大值
        {64, 127, 127},   // 最大值重复，包含中间值
        {1, 2, 3},        // 连续递增
        {127, 126, 125},  // 连续递减
        {1, 64, 64},      // 最小值+重复的中间值
        {1, 1, 127},      // 最小值重复，包含最大值
        {127, 1, 1},      // 最大值+最小值重复
        {127, 64, 1},     // 递减模式
        {1, 127, 64},     // 递增后递减
        {64, 127, 1}      // 递减后递增
    };

    int res = 0;
    for (int i = 0; i < 20; i++) {
        int a = testCases[i][0];
        int b = testCases[i][1];
        int c = testCases[i][2];
        res += test(a, b, c) == goodTest(a, b, c);
    }
    printf("得分为: %d / 20\n", res);
}

int main() {
    runTests();
    return 0;
}
```
