# C语言考试题目

> 注: 还没有严谨的说明场景, 代码之后我会改为C的, 现在只是抢先版qwq..

## 1. (简单题) 1278. 分割回文串 III

(这一题的场景还没有写)

给你一个由小写字母组成的字符串 `s`，和一个整数 `k`。

请你按下面的要求分割字符串:

- 首先，你可以将 `s` 中的部分字符修改为其他的小写英文字母。
- 接着，你需要把 `s` 分割成 `k` 个非空且不相交的子串，并且每个子串都是回文串。

> TIP:
> - "回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。

请返回以这种方式分割字符串所需修改的最少字符数。

**示例 1:**

**输入:** s = "abc", k = 2
**输出:** 1
**解释:** 你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。

**示例 2:**

**输入:** s = "aabbc", k = 3
**输出:** 0
**解释:** 你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。

**示例 3:**

**输入:** s = "leetcode", k = 8
**输出:** 0

**提示:**

- `1 <= k <= s.length <= 100`
- `s` 中只含有小写英文字母。

[https://leetcode.cn/problems/palindrome-partitioning-iii/solutions/](https://leetcode.cn/problems/palindrome-partitioning-iii/solutions/)


让他们写`isSB`这个函数 (判断需要`str[l...r]`最少需要修改几个字符, 使得`str[l...r]`为回文字符串)

```c++
class Solution {
public:
    int palindromePartition(string s, int z) {
        const int n = s.size();
        vector<vector<int>> f(z + 1, vector<int>(n + 1, 1e9));
        f[0][0] = 0;
/*
    f[i][j] = min{f[i - 1][k - 1] + isSb([k...j])}
*/
        auto isSb = [&](int l, int r) {
            int res = 0;
            while (l < r)
                if (s[l++] ^ s[r--])
                    ++res;
            return res;
        };

        for (int i = 1; i <= z; ++i) {
            for (int j = 1; j <= n; ++j) {
                for (int k = 1; k <= j; ++k) {
                    f[i][j] = min(
                        f[i][j],
                        f[i - 1][k - 1] + isSb(k - 1, j - 1)
                    );
                }
            }
        }
        return f[z][n];
    }
};
```

## 2. (位运算) 3309. 连接二进制表示可形成的最大数值

(第 418 场周赛 Q1)

给你一个长度为 `3` 的整数数组 `nums`。

现以某种顺序 **连接** 数组 `nums` 中所有元素的 **二进制表示** ，请你返回可以由这种方法形成的 **最大** 数值。

**注意** 任何数字的二进制表示 **不含** 前导零。

**示例 1:**

**输入:** nums = \[1,2,3\]

**输出:** 30

**解释:**

按照顺序 `[3, 1, 2]` 连接数字的二进制表示，得到结果 `"11110"`，这是 30 的二进制表示。

**示例 2:**

**输入:** nums = \[2,8,16\]

**输出:** 1296

**解释:**

按照顺序 `[2, 8, 16]` 连接数字的二进制表述，得到结果 `"10100010000"`，这是 1296 的二进制表示。

**提示:**

- `nums.length == 3`
- `1 <= nums[i] <= 127`

[https://leetcode.cn/problems/maximum-possible-number-by-binary-concatenation/description/](https://leetcode.cn/problems/maximum-possible-number-by-binary-concatenation/description/)

> 注: 到时候我们就调用`maxGoodNumber`即可, 这里可以让他们用指针和函数等等...

```C++
class Solution {
public:
    int maxGoodNumber(vector<int>& num) {
        auto bitlen = [&](int x) {
            int res = 0;
            while (x) {
                ++res;
                x>>=1;
            }
            return res;
        };
        auto fun = [&](int a, int b, int c) {
            int res = c;
            res |= b << bitlen(res);
            res |= a << bitlen(res);
            return res;
        };
        return max({
            fun(num[0], num[1], num[2]),
            fun(num[0], num[2], num[1]),
            fun(num[1], num[0], num[2]),
            fun(num[1], num[2], num[0]),
            fun(num[2], num[1], num[0]),
            fun(num[2], num[0], num[1]),
        });
    }
};
```

## 3. 年轻人不讲武德

Heng_Xin 在第140场双周赛的时候死磕T4 (题目在下面: 《3303. 第一个几乎相等子字符串的下标》), 然而均以超时告终, 这个是他超时的代码.

> 代码思路: 采用一个长度为`pattern.size()`的窗口, 一开始从头开始匹配, 

```C++
s = abcdef
pattern = dff

// 初状态:
头指针 L (指向 a)
|
v
abcdef
  ^
  |
  尾指针 R (指向 c) // 头尾结点可以看做是左右边界, 在 [L, R] 这个范围, 就是一个窗口, 长度为 pattern 的长度, 即 3

// 发现 a 不是 pattern 的第一个字符(d)
// 并且 c 也不是 pattern 的最后一个字符(f)
/* 因此, ++L, ++R */

// 然后是这样:
 头指针 L (指向 b)
 |
 v
abcdef
   ^
   |
   尾指针 R (指向 d)
// 还是一样的...直到:

   头指针 L (指向 d)
   |
   v
abcdef
     ^
     |
     尾指针 R (指向 f)
// 发现 d 是 pattern 的第一个字符(d)

// 那么就判断整个 [L, R] 的字符串, 看看需要替换的字符数量是否 <= 1
// 如果是, 那么就是答案
// 否则继续移动
```

```C++
class Solution {
public:
    int minStartingIndex(const string& s, const string& pattern) {
        int l = 0, r = pattern.size() - 1, n = s.size();
        while (r < n) {
        	// 先判断头尾两个字符是否都是不同, 如果都是不同, 那么就可以看看下一个了
            if (s[l] != pattern.front() && s[r] != pattern.back() && pattern.size() >= 2) {
                ++l, ++r;
            } else {
                // 匹配看看
                int cnt = 0;
                for (int i = l, j = 0; j < pattern.size(); ++i, ++j) {
                    cnt += (s[i] != pattern[j]);
                    if (cnt >= 2)
                        break;
                }
                if (cnt <= 1)
                    return l;
                ++l, ++r;
            }
        }
        return -1;
    }
};
```

如你所见, 他是超时的, 但是他不讲武德, 采用了各种优化~~(当然是靠运气的, 赌测试数据刚好没有可以防得住我的...)~~, 最终他将上面的`for`的判断改为`相向双指针`判断.

即判断完一边的一个字符, 就判断另一个的一个字符

```C++
// 例如下面这个例子
char s[n] = "abcdefg";       // s的长度就是 n
char pattern[m] = "abXdefg"; // 长度就是 m

首先, 初始是这样的:

L
|
v
abcdefg
      ^
      |
      R

发现 s[L] == pattern[0], 然后判断 s[R] == pattern[m - 1],
然后才继续 ++L, 再次判断 s[L] == pattern[1],
然后又回到 --R, 又来判断 s[R] ==  pattern[m - 2]

// 故称为相向双指针
```

---

### 3303. 第一个几乎相等子字符串的下标

给你两个字符串 `s` 和 `pattern` 。

如果一个字符串 `x` 修改 **至多** 一个字符会变成 `y` ，那么我们称它与 `y` **几乎相等**。

请你返回 `s` 中下标 **最小** 的 **子字符串**，它与 `pattern` **几乎相等** 。如果不存在，返回 `-1`。

**子字符串** 是字符串中的一个 **非空**、连续的字符序列。

**示例 1：**

**输入：** s = "abcdefg", pattern = "bcdffg"

**输出：** 1

**解释：**

将子字符串 `s[1..6] == "bcdefg"` 中 `s[4]` 变为 `"f"` ，得到 `"bcdffg"` 。

**示例 2：**

**输入：** s = "ababbababa", pattern = "bacaba"

**输出：** 4

**解释：**

将子字符串 `s[4..9] == "bababa"` 中 `s[6]` 变为 `"c"` ，得到 `"bacaba"` 。

**示例 3：**

**输入：** s = "abcd", pattern = "dba"

**输出：** -1

**示例 4：**

**输入：** s = "dde", pattern = "d"

**输出：** 0

**提示：**

- `1 <= pattern.length < s.length <= 105`
- `s` 和 `pattern` 都只包含小写英文字母。

[https://leetcode.cn/problems/find-the-occurrence-of-first-almost-equal-substring/](https://leetcode.cn/problems/find-the-occurrence-of-first-almost-equal-substring/)

---


```C++
// 答案
class Solution {
public:
    int minStartingIndex(string s, string pattern) {
        int l = 0, r = pattern.size() - 1, n = s.size();
        while (r < n) {
            if (s[l] != pattern.front() && 
                s[r] != pattern.back() && 
                pattern.size() >= 2
                ) {
                ++l, ++r;
            } else {
                // 匹配看看
                int cnt = 0;
                for (int i = l, a = r, j = 0, b = pattern.size() - 1; 
                    j <= b;
                    ++i, --a, ++j, --b) {
                    cnt += (s[i] != pattern[j]);
                    if (j != b)
                        cnt += (s[a] != pattern[b]);
                    if (cnt >= 2)
                        break;
                }
                if (cnt <= 1)
                    return l;
                ++l, ++r;
            }
        }
        return -1;
    }
};
```

## 4. (实际问题) 成为伟大的MCのOP

最近 Heng_Xin 开了一个MineCraft(我的世界) Jvav 1.20.1 的生电服务器.

然而, 还没有几个小时他的MC服务器就崩了! WDF?! 这究竟是怎么一回事?!

排查发现, 是因为常加载区块的原因, 刷线机一直在刷线, 而搜集系统(漏斗)已经满了.. 掉落物就一直堆在那里 (玩家下线了也还在运行...) (最后掉落物都已经围成一个圆圈了 (拜托, `线`这个掉落物是二维的诶! 它聚合在一个点, 然后不同的面上看它, 都是2D的内容通过不同的旋转, 形成了一个3D的球了...))

因此, Heng_Xin 需要一个扫地大妈, 每隔一段时间就清理掉落物.. 并且是以下这样显示:

```C++
// TODO 到时候给他们一个颜色表, 让他们现学颜色打印.

还有 10 分钟就清理掉落物了!
// 10 min 后
还有 1 分钟就清理掉落物了!
// 1 min 后
还有 10 秒就清理掉落物了!
还有 9 秒就清理掉落物了!
...
还有 2 秒就清理掉落物了!
还有 1 秒就清理掉落物了!
正在清理掉落物... // kill @e[type=item]
```

然而这个实际上是会在服务器日志上显示的, 比如: (这个是日志节选)

```java
[13:35:19] [Server thread/INFO]: [Server] §e还有 §b1 分钟 §e就清理掉落物啦~
[13:36:19] [Server thread/INFO]: [Server] §a还有 §e10 §a就清理掉落物啦~
[13:36:20] [Server thread/INFO]: [Server] §a还有 §e9 §a就清理掉落物啦~
[13:36:21] [Server thread/INFO]: [Server] §a还有 §e8 §a就清理掉落物啦~
[13:36:22] [Server thread/INFO]: [Server] §a还有 §e7 §a就清理掉落物啦~
[13:36:23] [Server thread/INFO]: [Server] §a还有 §e6 §a就清理掉落物啦~
[13:36:24] [Server thread/INFO]: [Server] §a还有 §e5 §a就清理掉落物啦~
[13:36:25] [Server thread/INFO]: [Server] §a还有 §e4 §a就清理掉落物啦~
[13:36:26] [Server thread/INFO]: [Server] §a还有 §e3 §a就清理掉落物啦~
[13:36:27] [Server thread/INFO]: [Server] §a还有 §e2 §a就清理掉落物啦~
[13:36:28] [Server thread/INFO]: [Server] §a还有 §e1 §a就清理掉落物啦~
[13:36:29] [Server thread/INFO]: [Server] §c正在清理掉落物...
[13:36:29] [Server thread/INFO]: Killed 18 entities
[13:36:29] [Server thread/INFO]: [Server] §a清理掉落物结束!
```

可是, 如果玩家不在线的话, 实际上没有必要清理掉落物。。。(总之就是不用)

现在, 我提供了`int getPlayerList()`函数, 以获取当前在线的玩家数量(返回值: 0 ~ 2233)

然后又提供了一个`void mySleep(int s)`函数, 表示暂停`s`秒.

最终需要使用C语言实现扫地小llの效果是这样的: (不要改我文本!)

0. 启动程序的时候, 必定打印一句`"已经启动扫地小萝莉~"`, 并且有两种状态
	- 状态一: 当前没有玩家 (默认启动的时候初始化为此)
    - 状态二: 当前有玩家

1. 每隔 10 min 检查是否有玩家
	- 如果有玩家, 并且是`状态一`, 则打印一句`いらっニャーいませ~ 掃除ロリっ子やる気満々~`(这句话只打印一次, 直到再次为状态一), 然后切换到`状态二`. (然后打印清理消息/执行清理命令等等)
    
    - 如果有玩家, 并且是`状态二`, 则只是 打印清理消息/执行清理命令等等
    
    - 如果没有玩家, 并且是`状态一`, 那么继续休眠 10min
    
    - 如果没有玩家, 并且是`状态二`, 那么切换到`状态一`, 并且打印一句"お疲れ様でした~", 休眠 10min.

2. while (1) 执行 `1.`

3. 注: 请在while的最后一句添加`getchar()`, 以作为一次的暂停, 好方便我们改分.

(TIP: 我Linux不是使用C作为脚本的, 而是写的`shell`脚本)

```sh
#!/bin/bash

fifo_file="mc.fifo"

echo "say §a 已经启动扫地小萝莉~" > $fifo_file

savestate=0
tag=0

while true; do
    echo "list" > mc.fifo
    sleep 1s # 间隔1s保证更新
    latest=$(tail -1 log.log)
    if [[ "$latest" =~ "There are 0" ]]; then
        savestate=0
        if [ $tag -eq 1 ]; then
        echo "say §dお疲れ様でした~" > $fifo_file
            tag=0
        fi
    else
        if [ $tag -eq 0 ]; then
        echo "say §dいらっニャーいませ~ 掃除ロリっ子やる気満々~" > $fifo_file
            tag=1
        fi
        savestate=1
    fi

    # 有人, 才会清理垃圾
    if [ $savestate -eq 1 ]; then
        echo "say §e还有 §b10 分钟 §e就清理掉落物啦~" > $fifo_file
        sleep 10m # 每10分钟进行一次清理

        echo "say §e还有 §b1 分钟 §e就清理掉落物啦~" > $fifo_file # 发送通知, §a 表示绿色
        sleep 1m

        for ((i=10; i>0; i--)); do
            echo "say §a还有 §e$i §a就清理掉落物啦~" > $fifo_file # 发送通知, §a 表示绿色
            sleep 1 # 1 s
        done

        # 执行清理掉落物命令
        echo "say §c正在清理掉落物..." > $fifo_file # 发送清理开始的通知，§c 表示红色
        echo "kill @e[type=item]" > $fifo_file # 清理掉落物
        echo "say §a清理掉落物结束!" > $fifo_file # 清理完成的通知，§a 表示绿色
    else
        sleep 10m # 间隔10 min检查是否有人
    fi
done
```

> 到时候我会改为 C语言的.